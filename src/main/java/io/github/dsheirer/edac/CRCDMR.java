/*******************************************************************************
 * sdr-trunk
 * Copyright (C) 2014-2018 Dennis Sheirer
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by  the Free Software Foundation, either version 3 of the License, or  (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; without even the implied
 * warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License  along with this program.
 * If not, see <http://www.gnu.org/licenses/>
 *
 ******************************************************************************/
package io.github.dsheirer.edac;

import io.github.dsheirer.bits.BinaryMessage;
import io.github.dsheirer.bits.CorrectedBinaryMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;

/**
 * P25 CRC check/correction methods
 */
public class CRCDMR
{
    private final static Logger mLog = LoggerFactory.getLogger(CRCDMR.class);

    /**
     * CRC-CCITT 16-bit checksums for a message length of 80 bits plus 16
     * additional checksums representing CRC checksum bit errors
     *
     * Generated by:
     * CRCUtil.generate( 80, 16, 0x11021l, 0xFFFFl, true );
     */
    public static final int[] CCITT_80_CHECKSUMS = new int[]
        {
            0x1BCB, 0x8DE5, 0xC6F2, 0x6B69, 0xB5B4, 0x52CA, 0x2175, 0x90BA, 0x404D,
            0xA026, 0x5803, 0xAC01, 0xD600, 0x6310, 0x3998, 0x14DC, 0x27E, 0x92F,
            0x8497, 0xC24B, 0xE125, 0xF092, 0x7059, 0xB82C, 0x5406, 0x2213, 0x9109,
            0xC884, 0x6C52, 0x3E39, 0x9F1C, 0x479E, 0x2BDF, 0x95EF, 0xCAF7, 0xE57B,
            0xF2BD, 0xF95E, 0x74BF, 0xBA5F, 0xDD2F, 0xEE97, 0xF74B, 0xFBA5, 0xFDD2,
            0x76F9, 0xBB7C, 0x55AE, 0x22C7, 0x9163, 0xC8B1, 0xE458, 0x7A3C, 0x350E,
            0x1297, 0x894B, 0xC4A5, 0xE252, 0x7939, 0xBC9C, 0x565E, 0x233F, 0x919F,
            0xC8CF, 0xE467, 0xF233, 0xF919, 0xFC8C, 0x7656, 0x333B, 0x999D, 0xCCCE,
            0x6E77, 0xB73B, 0xDB9D, 0xEDCE, 0x7EF7, 0xBF7B, 0xDFBD, 0xEFDE, 0x0001,
            0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200,
            0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
        };

    /**
     * Confirmed Packet Data Unit CRC-9 checksums, generated by:
     *
     * long[] table = CRCUtil.generate( 135, 9, 0x259l, 0x1FF, false, Parity.NONE );
     */
    public static final int[] CRC9_CHECKSUMS = new int[]
        {
            0x1E7, 0x1F3, 0x1F9, 0x1FC, 0x0D2, 0x045, 0x122, 0x0BD, 0x15E, 0x083,
            0x141, 0x1A0, 0x0FC, 0x052, 0x005, 0x102, 0x0AD, 0x156, 0x087, 0x143,
            0x1A1, 0x1D0, 0x0C4, 0x04E, 0x00B, 0x105, 0x182, 0x0ED, 0x176, 0x097,
            0x14B, 0x1A5, 0x1D2, 0x0C5, 0x162, 0x09D, 0x14E, 0x08B, 0x145, 0x1A2,
            0x0FD, 0x17E, 0x093, 0x149, 0x1A4, 0x0FE, 0x053, 0x129, 0x194, 0x0E6,
            0x05F, 0x12F, 0x197, 0x1CB, 0x1E5, 0x1F2, 0x0D5, 0x16A, 0x099, 0x14C,
            0x08A, 0x069, 0x134, 0x0B6, 0x077, 0x13B, 0x19D, 0x1CE, 0x0CB, 0x165,
            0x1B2, 0x0F5, 0x17A, 0x091, 0x148, 0x088, 0x068, 0x018, 0x020, 0x03C,
            0x032, 0x035, 0x11A, 0x0A1, 0x150, 0x084, 0x06E, 0x01B, 0x10D, 0x186,
            0x0EF, 0x177, 0x1BB, 0x1DD, 0x1EE, 0x0DB, 0x16D, 0x1B6, 0x0F7, 0x17B,
            0x1BD, 0x1DE, 0x0C3, 0x161, 0x1B0, 0x0F4, 0x056, 0x007, 0x103, 0x181,
            0x1C0, 0x0CC, 0x04A, 0x009, 0x104, 0x0AE, 0x07B, 0x13D, 0x19E, 0x0E3,
            0x171, 0x1B8, 0x0F0, 0x054, 0x006, 0x02F, 0x117, 0x18B, 0x1C5, 0x1E2,
            0x0DD, 0x16E, 0x09B, 0x14D, 0x1A6
        };


    /*
    /**
     * Performs error detection and single-bit error correction against the
     * data blocks of a PDU1 message.

     */
    public static BinaryMessage correctCSBK(BinaryMessage message, long[] checksums, int crcStart)
    {
        long calculated = 0; //Starting value

        int messageStart = 160;

        /* Iterate the set bits and XOR running checksum with lookup value */
        for(int i = message.nextSetBit(messageStart);
            i >= messageStart && i < crcStart;
            i = message.nextSetBit(i + 1))
        {
            calculated ^= checksums[i - messageStart];
        }

        long checksum = getLongChecksum(message, crcStart, 32);

        long error = calculated ^ checksum;

        if(error == 0 || error == 0xFFFFFFFFl)
        {
            message.setCRC(CRC.PASSED);

            return message;
        }
        else
        {
            int errorLocation = getBitError(error, checksums);

            if(errorLocation >= 0)
            {
                message.flip(errorLocation + messageStart);

                message.setCRC(CRC.CORRECTED);

                return message;
            }
        }

        message.setCRC(CRC.FAILED_CRC);

        return message;
    }

    /**
     * Error detection and correction of single-bit errors for CCITT 16-bit
     * CRC protected 80-bit messages.
     */
    public static BinaryMessage correctCCITT80(BinaryMessage message,
                                               int messageStart,
                                               int crcStart)
    {
        int calculated = 0; //Starting value

        /* Iterate the set bits and XOR running checksum with lookup value */
        for(int i = message.nextSetBit(messageStart);
            i >= messageStart && i < crcStart;
            i = message.nextSetBit(i + 1))
        {
            calculated ^= CCITT_80_CHECKSUMS[i - messageStart];
        }

        int checksum = getIntChecksum(message, crcStart, 16);

        int residual = calculated ^ checksum;

        if(residual == 0 || residual == 0xFFFF)
        {
            message.setCRC(CRC.PASSED);

            return message;
        }
        else
        {
            int errorLocation = getBitError(residual, CCITT_80_CHECKSUMS);

            if(errorLocation >= 0)
            {
                message.flip(errorLocation + messageStart);

                message.setCRC(CRC.CORRECTED);

                return message;
            }
        }

        message.setCRC(CRC.FAILED_CRC);

        return message;
    }

    /**
     * Error detection and correction of single-bit errors for CCITT 16-bit
     * CRC protected 80-bit messages.
     */
    public static int correctCCITT80(CorrectedBinaryMessage message, int messageStart, int crcStart, int type)
    {
        int calculated = type; //Starting value

        /* Iterate the set bits and XOR running checksum with lookup value */
        for(int i = message.nextSetBit(messageStart); i >= messageStart && i < crcStart; i = message.nextSetBit(i + 1))
        {
            calculated ^= CCITT_80_CHECKSUMS[i - messageStart];
        }

        int checksum = getIntChecksum(message, crcStart, 16);

        int residual = calculated ^ checksum;

        if(residual == 0 || residual == 0xFFFF)
        {
            return 0;
        }
        else
        {
            int errorLocation = getBitError(residual, CCITT_80_CHECKSUMS);

            if(errorLocation >= 0)
            {
                message.flip(errorLocation + messageStart);
                message.incrementCorrectedBitCount(1);
                return 1;
            }
        }

        //Message has at least 2 bit errors - ie uncorrectable
        message.incrementCorrectedBitCount(2);

        return 2;
    }

    /**
     * Error detection for CRC-9 protected Confirmed Packet Data blocks.  These
     * data blocks have a slightly complicated structure because the checksum
     * is located between bits 7-15, within a 144 bit block.  The checksums
     * were generated assuming that the message is contiguous from 0 - 134 bits.
     * No data correction is performed.
     */
    public static CRC checkCRC9(BinaryMessage message, int messageStart)
    {
        int calculated = 0x0; //Initial fill of all ones

        /* Iterate the set bits and XOR running checksum with lookup value */
        for(int i = message.nextSetBit(messageStart);
            i >= messageStart && i < messageStart + 144;
            i = message.nextSetBit(i + 1))
        {
            /* message bits before the CRC */
            if(i < (messageStart + 7))
            {
                calculated ^= CRC9_CHECKSUMS[i - messageStart];
            }
            /* message bits after the CRC */
            else if(i > (messageStart + 15))
            {
                calculated ^= CRC9_CHECKSUMS[i - messageStart - 9];
            }
        }

        int checksum = message.getInt(messageStart + 7, messageStart + 15);

        int residual = calculated ^ checksum;

//		mLog.debug( "CALC:" + calculated + " CHECK:" + checksum + " RESID:" + residual );

        if(residual == 0 || residual == 0x1FF)
        {
            return CRC.PASSED;
        }

        return CRC.FAILED_CRC;
    }


    /**
     * Performs Galois 24/12/7 error detection and correction against the 12
     * encoded 24-bit message segments following the 64-bit NID in the message
     *
     * @return - true if all 12 segments of the message can be checked/corrected
     */
    public static boolean correctGalois24(CorrectedBinaryMessage tdulc)
    {
        boolean passes = true;

        int x = 64;

        while(x < tdulc.size() && passes)
        {

            int errors = Golay24.checkAndCorrect(tdulc, x);

            passes = errors < 2;

            x += 24;
        }

        return passes;
    }


    /**
     * Calculates the value of the message checksum as a long
     */
    public static long getLongChecksum(BinaryMessage message,
                                       int crcStart, int crcLength)
    {
        return message.getLong(crcStart, crcStart + crcLength - 1);
    }

    /**
     * Calculates the value of the message checksum as an integer
     */
    public static int getIntChecksum(BinaryMessage message,
                                     int crcStart, int crcLength)
    {
        return message.getInt(crcStart, crcStart + crcLength - 1);
    }

    /**
     * Identifies any single bit error position that matches the checksum error.
     */
    public static int getBitError(long checksumError, long[] checksums)
    {
        for(int x = 0; x < checksums.length; x++)
        {
            if(checksums[x] == checksumError)
            {
                return x;
            }
        }

        return -1;
    }

    /**
     * Identifies any single bit error position that matches the checksum error.
     */
    public static int getBitError(int checksumError, int[] checksums)
    {
        for(int x = 0; x < checksums.length; x++)
        {
            if(checksums[x] == checksumError)
            {
                return x;
            }
        }

        return -1;
    }
    public static int crc8(BinaryMessage bits, int len) {
        int crc=0;
        final int K = 8;
        final boolean[] poly = new boolean[]{true,false,false,false,false,false,true,true,true}; // crc8 poly
        boolean[] buf = new boolean[256];
        if (len+K > 256) {
            return 0;
        }
        for (int i=0; i<len; i++){
            buf[i] = bits.get(i);
        }
        for (int i=0; i<len; i++)
            if (buf[i])
                for (int j=0; j<K+1; j++)
                    buf[i+j] ^= poly[j];
        for (int i=0; i<K; i++){
            crc = (crc << 1) + (buf[len + i] ? 1:0);
        }
        return crc;
    }
    public static void main(String[] args)
    {
        String raw = "100000010000011001010001010100100101001101011100000010110000000000000000000010110000001001111001";

        CorrectedBinaryMessage message = new CorrectedBinaryMessage(96);
        try
        {
            for(int i = 0; i < 96; i++) {
                message.add(raw.charAt(i) == '0' ? false :true);
            }
            mLog.debug("MSG:" + message.toString());

            int ret = correctCCITT80(message, 0, 80, 0xa5a5);//

            mLog.debug("COR:" + message.toString());

            mLog.debug("Results: " + ret);
        } catch(Exception ex) {
            ex.printStackTrace();
        }


    }
}
